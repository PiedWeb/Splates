<?php

declare(strict_types=1);

namespace PiedWeb\Splates;

use PhpParser\Comment\Doc;
use PhpParser\Modifiers;
use PhpParser\Node;
use PhpParser\Node\Expr;
use PhpParser\Node\Expr\ConstFetch;
use PhpParser\Node\Name;
use PhpParser\Node\Param;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\UnionType;
use PHPStan\Type\NullType;
use PHPStan\Type\Type;
use PiedWeb\Splates\Template\DoNotAddItInConstructorInterface;
use PiedWeb\Splates\Template\Template;
use PiedWeb\Splates\Template\TemplateClass;
use PiedWeb\Splates\Template\TemplateClassInterface;
use Rector\NodeTypeResolver\NodeTypeResolver;
use Rector\NodeTypeResolver\NodeTypeResolver\ParamTypeResolver;
use Rector\PhpParser\Printer\BetterStandardPrinter;
use Rector\Rector\AbstractRector;
use Rector\StaticTypeMapper\ValueObject\Type\FullyQualifiedObjectType;
use Rector\ValueObject\MethodName;

/**
 * Rewrite
 * `final class SomeTemplate { public function display(string $name, Template $t): void { ... } }`
 * in
 * `final class SomeTemplate { public function display(string $name, Template $t): void { ... } public function __construct(public string $name) {} }`
 */
final class RectorizeTemplate extends AbstractRector
{
    public const CLASS_TO_NOT_ADD_IN_CONSTRUCTOR = [
        Template::class,
        TemplateClass::class,
        DoNotAddItInConstructorInterface::class,
    ];

    public const PARAMETER_NAMES_TO_NOT_ADD = ['f', 'e'];

    public function __construct(
        private readonly ParamTypeResolver $paramTypeResolver,
        protected NodeTypeResolver $nodeTypeResolver,
        private readonly BetterStandardPrinter $betterStandardPrinter
    ) {
    }

    public function getNodeTypes(): array
    {
        return [Class_::class];
    }

    public function refactor(Node $node): ?Node
    {
        if (! $node instanceof Class_) {
            return null;
        }

        $implementedInterfaces = array_map(static fn (Name $interface): string => $interface->toString(), $node->implements);

        if (! \in_array(TemplateClassInterface::class, $implementedInterfaces, true)) {
            return null;
        }

        $displayMethod = $node->getMethod('display');
        if ($displayMethod === null || $displayMethod->params === []) {
            $this->removeConstructor($node);
            return null;
        }

        $paramsForConstructor = [];
        $docBlockForConstructor = [];
        $methodDocBlock = $displayMethod->getDocComment()?->getText() ?? '';

        foreach ($displayMethod->params as $parameter) {
            if (in_array($this->getName($parameter), self::PARAMETER_NAMES_TO_NOT_ADD, true)) {
                continue;
            }

            $paramType = $this->paramTypeResolver->resolve($parameter);
            if ($paramType instanceof FullyQualifiedObjectType && ! $this->mustAddObjectInConstructor($parameter, $paramType)) {
                continue;
            }

            $paramDocBlock = $this->getParameterDocblock($methodDocBlock, $this->getName($parameter));
            if ($paramDocBlock !== null) {
                $docBlockForConstructor[] = $paramDocBlock;
            }

            $cloneParameter = clone $parameter;
            $cloneParameter->flags = Modifiers::PUBLIC;

            if ($parameter->default instanceof Expr
                && (! $this->hasNullType($paramType)
                && $parameter->default instanceof ConstFetch
                && $this->hasNullValue($parameter))) {
                //($cloneParameter, 'null');
            }

            $paramsForConstructor[] = $cloneParameter;
        }

        if ($paramsForConstructor === []) {
             $this->removeConstructor($node);
             return null;
        }

        $constructor = $node->getMethod(MethodName::CONSTRUCT);
        $docBlockConstructor = $constructor?->getDocComment();
        $dockBlockContent = trim("Autogenerated constructor.\n * \n * ".implode("\n * ", $docBlockForConstructor), "\n *");
        $newDocBlockConstructor = new Doc("/**\n * ".$dockBlockContent."\n */");
        if ($paramsForConstructor === $constructor?->params || $docBlockConstructor === $newDocBlockConstructor) { // TODO compare docblock
            return null;
        }
        $newConstructor = new ClassMethod(MethodName::CONSTRUCT, [
            'flags' => Modifiers::PUBLIC,
            'params' => $paramsForConstructor,
        ]);
        $newConstructor->setDocComment($newDocBlockConstructor);

        $this->removeConstructor($node);
        $node->stmts[] = $newConstructor;

        return $node;
    }

    private function hasNullType(Type $type): bool
    {
        return $type->isNull()->maybe()  ;
        // if ($type instanceof NullType) {
        //     return true;
        // }

        // if ($type instanceof \PHPStan\Type\UnionType) {
        //     foreach ($type->getTypes() as $innerType) {
        //         if ($this->hasNullType($innerType)) {
        //             return true;
        //         }
        //     }
        // }

        // return false;
    }

    private function hasNullValue(Param $param): bool
    {
        $text = $this->betterStandardPrinter->print($param);

        return str_ends_with($text, 'null');
    }

    private function removeConstructor(Class_ $class): void
    {
        foreach ($class->stmts as $key => $stmt) {
            if ($stmt instanceof ClassMethod && $stmt->name->toString() === MethodName::CONSTRUCT) {
                unset($class->stmts[$key]);

                break;
            }
        }
    }

    private function getParameterDocblock(?string $methodDocblock, string $parameterName): ?string
    {
        if ($methodDocblock === null) {
            return null;
        }

        $pattern = '/@param\s+[^$]*?\$' . $parameterName . '\b([^@]*)/';

        if (preg_match($pattern, $methodDocblock, $matches)) {
            return trim($matches[0], '*/ ' . "\n");
        }

        return null;
    }

    private function mustAddObjectInConstructor(Param $param, FullyQualifiedObjectType $paramType): bool
    {
        if (\in_array($paramType->getClassName(), self::CLASS_TO_NOT_ADD_IN_CONSTRUCTOR, true)) {
            return false;
        }

        foreach (self::CLASS_TO_NOT_ADD_IN_CONSTRUCTOR as $classToCheck) {
            if (is_subclass_of($paramType->getClassName(), $classToCheck)) {
                return false;
            }
        }

        return true;
    }

    private function addTypeToParameter(Param $param, string $type): void
    {
        // $existingType = $this->nodeTypeResolver->getType($param);

        // if ($existingType instanceof \PHPStan\Type\UnionType) {
        //     $existingTypes = $existingType->getTypes();
        //     $newTypes = [...$existingTypes, new NullType()];
        //     $param->type = new UnionType($newTypes);

        //     return;
        // }

        // $param->type = null;

        // The following code is not working
        // $param->type = new UnionType([$existingType, new \PHPStan\Type\NullType()]);
        // Get it worked using nullable_type_declaration_for_default_null_value for phpcsfixer
    }
}
